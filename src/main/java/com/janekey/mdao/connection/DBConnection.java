package com.janekey.mdao.connection;

import org.apache.log4j.Logger;

import java.sql.*;

/**
 * Database connection encapsulate
 * User: Janekey(janekey.com)
 * Date: 13-4-22
 * Time: 上午12:10
 */
public class DBConnection {
	
	private static Logger logger = Logger.getLogger(DBConnection.class);
	
	// 连接池管理
	private DBConnectionManager connMgr = null;

	// 连接对象
	private Connection conn = null;

	// 执行SQL对象
	private PreparedStatement prepStmt = null;

	private ResultSet rs = null;

	public CallableStatement cstmt;

	public String poolName = "";

	/**
	 * 执行SQL
	 * @param poolName
	 * @param sql
	 * @throws java.sql.SQLException
	 */
	public DBConnection(String poolName, String sql) throws SQLException {
		this.poolName = poolName;
		connMgr = DBConnectionManager.getInstance();
		this.conn = connMgr.getConnection(poolName);
		prepStmt = conn.prepareStatement(sql);
	}

	/**
	 * 执行存储过程
	 * 
	 * @param poolName
	 * @throws java.sql.SQLException
	 */
	public DBConnection(String poolName) throws SQLException {
		this.poolName = poolName;
		connMgr = DBConnectionManager.getInstance();
		this.conn = connMgr.getConnection(poolName);
	}
	
	/**
	 * 创建PreparedStatement 对象
	 * 
	 * @param sql	SQL语句
	 * @throws java.sql.SQLException
	 */
	public void prepareStatement(String sql) throws SQLException {
		prepStmt = conn.prepareStatement(sql);
		
	}
	
	public void prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {
		prepStmt = conn.prepareStatement(sql, autoGeneratedKeys);
	}

	/**
	 * 用于产生单个结果集的语句，例如 SELECT 语句。
	 * @return
	 * @throws java.sql.SQLException
	 */
	public ResultSet executeQuery() throws SQLException {
		rs = this.prepStmt.executeQuery();
		return rs;
	}

	/**
	 * 用于执行 INSERT、UPDATE 或 DELETE 语句以及 SQL DDL（数据定义语言）语句，例如 CREATE TABLE 和 DROP TABLE。
	 * @return 
	 * @throws java.sql.SQLException
	 */
	public int executeUpdate() throws SQLException {
		return this.prepStmt.executeUpdate();
	}
	
	/**
	 * 执行INSERT语句
	 * @return 返回插入的ID
	 */
	public int executeInsert() throws SQLException {
		this.prepStmt.executeUpdate();
		int autoIncKeyFromApi = -1 ;
		ResultSet rs2 = null;
		try {
			rs2 = prepStmt.getGeneratedKeys();
			if(rs2.next()) {
				autoIncKeyFromApi = rs2.getInt(1);
			}
		} finally {
			if(rs2 != null && !rs2.isClosed()) {
				rs2.close();
			}
		}
		return autoIncKeyFromApi;
	} 

	/**
	 * 用于执行返回多个结果集、多个更新计数或二者组合的语句。
	 * @return
	 * @throws java.sql.SQLException
	 */
	public boolean execute() throws SQLException {
		return this.prepStmt.execute();
	}

	/**
	 * 设置参数列表
	 * @param params
	 * @throws java.sql.SQLException
	 */
	public void setParams(Object[] params) throws SQLException {
		int index = 0;
		for(Object obj : params) {
			index++;
			prepStmt.setObject(index, obj);
		}
	}
	
	/**
	 * 设置选定参数
	 * @param index
	 * @param param
	 * @throws java.sql.SQLException
	 */
	public void setParam(int index, Object param) throws SQLException {
		prepStmt.setObject(index, param);
	}
	
	/**
	 * 添加批处理
	 */
	public void addBatch() throws SQLException {
		prepStmt.addBatch();
	}
	
	/**
	 * 批处理执行
	 */
	public int[] executeBatch() throws SQLException {
		return prepStmt.executeBatch();
	}
	
	/**
	 * 有返回值的存储过程执行
	 * 
	 * @param sql
	 * @param params
	 * @return
	 * @throws java.sql.SQLException
	 */
	public ResultSet executeQueryProcedure(String sql, Object[] params)
			throws SQLException {
		int index = 0;
		cstmt = conn.prepareCall(sql);
		for (Object obj : params) {
			index++;
			cstmt.setObject(index, obj);
		}
		// cstmt.registerOutParameter(3, Types.INTEGER);
		rs = cstmt.executeQuery();
		return rs;
	}

	/**
	 * 返回boolean的存储过程
	 * 
	 * @param procName
	 * @param params
	 * @return
	 * @throws java.sql.SQLException
	 */
	public boolean executeProcedure(String procName, Object[] params)
			throws SQLException {
		boolean flag = false;
		int index = 0;
		cstmt = conn.prepareCall(procName);
		for (Object obj : params) {
			index++;
			cstmt.setObject(index, obj == null ? "" : obj);
		}
		flag = cstmt.execute();
		return flag;
	}

	public PreparedStatement getPrepStmt() {
		return prepStmt;
	}

	/**
	 * 使所有上一次提交/回滚后进行的更改成为持久更改，并释放此 Connection 对象当前持有的所有数据库锁。
	 */
	public void commit() {
		try {
			conn.commit();
		} catch (Exception e) {
			logger.info(e.getMessage());
		}
	}

	/**
	 * 取消在当前事务中进行的所有更改，并释放此 Connection 对象当前持有的所有数据库锁。
	 */
	public void rollback() {
		try {
			conn.rollback();
		} catch (Exception e) {
			logger.info(e.getMessage());
		}
	}

	/**
	 * 释放连接
	 * 
	 */
	public void free() {
		try {
			if (this.rs != null) {
				this.rs.close();
				this.rs = null;
			}
			if (this.prepStmt != null) {
				this.prepStmt.close();
				this.prepStmt = null;
			}

			if(conn != null) {
				if(!conn.getAutoCommit()) {
					this.commit();
					this.rollback();
				}
			}
		} catch (SQLException e) {
			logger.info(e.getMessage());
		}
		// 将用过的连接再回收到池中,在回收连接前,要保证上一连接操作完
		connMgr.freeConnection(poolName, this.conn);
	}
}
